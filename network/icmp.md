# თეორია

The Internet Control Message Protocol (ICMP) ამჟღავნებს პოტენციელურად სუსტად დაცულ ქსელებს. ICMP არის პატარა პროტოკოლი ქსელის სტატუსის შესახებ მესიჯების გასაგზავნად, იგი გამოიყენება ადმინისტრატორების მიერ ქსელების ტესტირებისთვის (ping-ის და traceroute-ის მეშვეობით). ICMP-ს პასუხების ანალიზით აგრეთვე შეიძლება ოპერაციული სისტემის დადგენა. 

**ქსელის სკანირებისთვის ყველაზე საინტერესოა შემდეგი ICMP ტიპის მესიჯები:**

| მესიჯის ტიპი    | აზსნა            |
| Type 8 (echo request)    | Echo request მესიჯი იხმარება ping-ის პაკეტების გაგზავნის დროს. ამითი ვიგებთ თუ გარკვეული კომპიუტერი ქსელში ჩართულია     | 
| Type 13 (timestamp request)    | Timestamp request მესიჯი მოითხოვს ინფორმაციას მიზანში ამოღებულ კომპიუტერის სისტემური დროის შესახებ. პასუხი მიდის ათობით ფორმატში და აღნიშნავს midnihgt GMT-დან გასულ მილიწამებს.   |
| Type 15 (information request)    | ICMP information request მესიჯი არის განკუთნილი თვითკონფიგურურების უნარიან სისტემებისთვის როგორც მაგალითად უდისკო კომპიუტერები, რომ ჩართვის დროს მიეცეს IP მისამართი. მაგრამ პროტოკოლები როგორებიც არიან RARP, BOOTP, ან DHCP ამას უკეთესად ასრულებენ, ასე რომ ამ ტიპის მესიჯი იშვიათად გამოიყენება.    | 
| Type 17 (subnet address mask request)   | ამ ტიპის მესიჯი პრაქტიკულია მიზანში ამოღებული host-ის subnet-ის მასკის დასადგენად. ეს ინფორმაცია გამოდგება subnet-ის ზომის დასადგენად ანუ რომელ მისამართიდან რომელ მისამართამდე გარკვეული subnet-ის განკარგულება, რამდენი host-ი შეიძლება იყოს კომპანიის subnet-ებში.  |
| სხვა  | სხვა საინტერესო ICMP მესიჯებიც არსებობს რომლებსაც უსაფროთხობასთან აქვს კავშირი (როგორიცაა ICMP ტიპის 5 გადამისამართების მესიჯები როუტერებისგან გაგზავნილი) მაგრამ ისინი არ არიან დაკავშირებული ქსელის სკანირებასთან.  |

**პოპულარული ოპერაციული სისტემების ზოგიერთ ICMP მესიჯებზე რეაგირება:**

| ოპერაციული სისტემა    | Direct ICMP message types (non-broadcast)  | | | | 
|         |  8  |  13 |  15 |  17 |  
| Linux   | კი | კი | არა  | არა | 
| *BSD    | კი | კი | არა  | არა |
| Solaris | კი | კი | არა  | კი |
| AIX     | კი | კი | კი  | არა |
| HP-UX   | კი | კი | კი | არა |
| Ultrix  | კი | კი | კი | კი |
| Cisco IOS | კი | კი | კი | არა |

არაპირდაპირი ICMP მესიჯების გაგზავნა შეიძლება subnet-ის broadcast-ის მისამართზე (როგორც 192.168.0.255, 122.168.0.0/24 ქსელში). ოპერაციული სისტემები პასუხს სხვადასხვანაირად ცემენ არაპირდაპირ ICMP query-ებს რომლებიც broadcast-ისთვის იყო გაგზავნილი. 

| ოპერაციული სისტემა    | Indirect ICMP message types (broadcast))  | | | |
|           |  8  |  13  |  15 |  17 |  
| Linux     | კი  | კი   | არა  | არა | 
| *BSD      | არა | არა | არა  | არა |
| Solaris   | კი  | კი   | არა  | არა |
| AIX       | არა | არა | არა  | არა |
| HP-UX     | კი  | კი   | კი   | არა |
| Ultrix    | არა | არა | არა  | არა |
| Cisco IOS | არა | არა | კი   | არა |

ოფირ არკინმა (Ofir Arkin) ბევრი იმუშავა ICMP-ს გამოყენებაზე ოპერაციული სისტემების ვერიების დასადგენად და ასე შემდეგ, მის დაწერილ დოკუმენტებს შეგიძლიათ გაეცნოთ: http://ofirarkin.wordpress.com/published-materials/papers/.

უმეტესი კომპანიების ქსელში ICMP არ არის ფილტრირებული იმიტომ რომ იგი ამავე დროს
პრაქტიკულია ქსელის დიაგნოსტიკისთვის პრობლემების დროს.

# პრაქტიკა

## Sing

Send ICMP Nasty Garbage (SING) არის ხელსაწყო რომლებაც შეუძლია ხელოვნურად შექმნილია ICMP პაკეტების გაგზავნა. მას შეუძლია ping-ის შეცვლა ზოგიერთი გაუმჯობესებით, როგორც:
  * გაყალბებული (spoofing) პაკეტების გაგზავნა და მიღება
  * გაყალბებული MAC-ით პაკეტების გაგზავნა
  * სხვადასხვა მესიჯის ტიპის მხარდაჭერა (ICMP address mask, timestamp, ინფორმაციის მოპოვება, როუტერთან დაკავშირება, 

ICMP echo-ს მესიჯის გაგზავნა broadcast-ის მეშვეობით:

```
# sing -echo 192.168.0.255
```

ICMP timestamp request-ის გაგზავნა:

```
# sing -tstamp 192.168.0.50
```

ICMP address mask request მესიჯის გაგზავნა:

```
# sing -mask 192.168.0.25
```

## nmap

192.168.0.0 subnet-ის ყოველ host-ის ICMP ping-ირება. ეს მოქმედებს თუ ფაირვოლი ან როუტერი ამ subnet-ისთან ICMP მესიჯებს არ ფილტრავს. 

```
# nmap -sP -PI 192.168.0.0/24
```

## შიდა IP მისამართების მოპოვება

ზოგჯერ შესაძლოა შიდა IP მისამართების დადგენა, ICMP პასუხების ანალიზით. ანილიზი ხდება statefull ინსპექციის სისტემებით, მაგალითად პერსონალური ფაირვოლი რომელიც ლოკალურ ქსელში მყოფ კომპიუტერშია გაშვებული და ტრეფკის ინსპექცია ახორციელებს.

  - საჯარო მისამართზე ICMP echo request-ის გაგზავნა
  - ხშირად ფაირვოლი NAT (network address translation) მექანიზმს ხმარობს რომ პაკეტი გადასცეს იმ შიდა ქსელში მყოფ კოპიუტერს რომელსაც ერგება. თუ ფაირვოლი ისეა კონფიგურირებული რომ ICMP echo request მესიჯებს გადალახვა შეეძლოთ და იგი შიდა ქსელში იყოს გაგზავნილი (ამის წინააღმდეგი მაგალითია პროქსის მიერ header-ების შეცვლა), მაშინ ზოგჯერ არა მოთხოვნილ ICMP echo reply მესიჯებს შეეძლებათ გამოიგზავნონ შიდა ქსელის მისამართებიდან.

nmap-ს და sing-ს არ შეუძლიათ რომ "ნახონ" ქსელის შიდა მისამართებიდან წამოსული პასუხები იმიტომ ამისთვის low level statefull ანალიზია საჭირო.

ეს ფაირვოლებს და სნიფერებს შეუძლიათ:
  * ვინდოუსში მაგალითად IIS BlackICE-ში უნდა ნახოთ ხაზი რომელშიც მითითებულია: Echo reply without request   243.53.22.3).
  * ლინუქსში შეგძლიათ იხმაროთ tcpdump-ი და მოძებნოთ პასუხ პაკეტებში ICMP echo reply მესიჯები და გაფილტროთ საჯარო და არა საჯარო მისამართები.


## subnet-ის broadcast-ის მისამართების დადგენა

subnet-ის broadcast-ის მისამართი შეგვიძლია გავიგოთ nmap-ის ფუნქციით რომელიც ითვლის ICMP echo replie-ებს როდესაც subnet-ის ping-ირება იწყება. broadcast-ის მისამართი პასუხს გასცემს მრავალი ICMP echo reply-ებით თუ ICMP მესიჯები არ არის ფილტრირებული, რაც საშუალებას გაძლევთ რომ ნახოთ როგორ არის ქსელი სეგმენტირებული.

subnet-ის broadcast მისამართების გამოცნობა (ADSL როუტერები და სისტემები):

```
# nmap -sP 62.2.15.0/24
```

ამ სკანირებით ვადგენთ რომ არის 3 subnet-ი, 62.2.15.0 ქსელში:

  * abc.co.uk subnet-ი 62.2.15.8-დან 62.2.15.15-მდე (8 მისამართი)
  * smallco.net subnet-ი 62.2.15.16-დან 62.2.15.19-მდე (4 მისამართი)
  * example.org subnet-ი 62.2.15.20-დან 62.2.15.35-მდე (16 მისამართი)


# დაცვა

გამოგზავნილი ICMP მესიჯების ფილტრაცია ფაირვოლის ან როუტერის მიერ. ეს ICMP სკანირებას არა ეფექტურს ხდის.
უკან გასაგზავნი ICMP type 3 unreachable მესიჯების დაბლოკვა, ამით UDP პორტების სკანირება ვერ განხორციელდება.
