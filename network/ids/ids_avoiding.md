პორტ სკანირების დროს რომ IDS-ისგან შეუმჩნეველი (IDS evasion) დარჩეთ უნდა გამოიყენოთ ერთერთი ან ორივე შემდეგი ტაქტიკა:
  * ფრაგმენტირებული პაკეტების გაგზავნა, რომლებიც აწყობილნი იქნებიან როცა მსხვერპლი მიიღებს
  * მრავალი სპუფირებული (spoofing) პაკეტების გამოყენება სკანირების დროს, ამ პაკეტების წყარო IP მისამართი იქნება ყალბი, ერთის გარდა, რომელიც იქნება თქვენი ნამდვილი IP რომ პასუხი უკან მოგივიდეთ. ამ მასაში თქვენი IP-ი შერეული იქნება სხვა IP-ებთან რაც ჰაკერის IP-ის გარჩევას გაართულებს.

ფილტრაციის მექანიზმების მოტყუებაც შეიძლება ხოლმე არასწორი (malformed) ან ფრაგმენტირებული პაკეტების გამოყენებით. მაგრამ ხშირად ან საქმისთვის შემდეგი ტექნიკები იხმარება:
  * წყარო მარშუტი (source routing)
  * სპეციფიკური TCP ან UDP გამოყენება წყარო პორტად

# პაკეტების ფრაგმენტირება

უმეტეს IDS-ს უჭირს ან არ შეუძლია ბევრი ფრაგმენტირებული პაკეტის დახარისხირება იმიტომ რომ ეს პროცესი მოითხოვს ბევრ მეხსიერებას და აგრეთვე ძლიერ CPU-ს.

## fragtest

fragtest-ს (fragoute პაკეჯის ნაწილი, http://www.monkey.org/~dugsong/fragroute/) შეუძლია დაადგინოს რომელი ტიპის ფრაგმენტირებული ICMP მესიჭებს პასუხობს ან დადებითად იღებს შორეული host-ი.
ICMP echo request მესიჯებს იყენებს სიმარტივის გამო და ანალიზისთვის; ამ სტრატეგიის უარყოფითი კუთხე ისაა რომ fragtest-ს არ შეუძლია დატესტოს  host-ები რომლებიც ICMP მესიჯებს არ პასუხობენ.

რომ დარწმუნდეთ რომ შორეული კომპიუტერი ICMP მესიჯებს პასუხობს გამოიყენეთ ხელსაწყო sing-ი.

fragtest-ს შეუძლია სამ ნაირი საინტერესო ტესტის განხორციელება:

  * ICMP echo request მესიჯის გაგზავნა,  8-ბაიტად დაყოფილი ფრაგმენტირებით (frag პარამეტრი)

  * ICMP echo request მესიჯის გაგზავნა, 8-ბაიტად დაყოფილი ფრაგმენტებით, რასაც შეერევა 16-ბაიტიანი ფრაგმენტი, პაკეტის აწყობის (reassembly) დროს კი ახალ მონაცემს ექნება შანსი რომ იგი წარმოჩნდეს (frag-new პარამეტრი)

  * ICMP echo request მესიჯის გაგზავნა, 8-ბაიტიან დაყოფილ ფრაგმენტებით, რასაც შეერევა 16-ბაიტიანი ფრაგმენტი, პაკეტის აწყობის დროს კი ძველ  მონაცემს ექნება შანსი რომ იგი წარმოჩნდეს (frag-old პარამეტრი)

```
# fragtest frag frag-new frag-old www.bbc.co.uk

frag: 467.695 ms

frag-new: 516.327 ms

frag-old: 471.260 ms
```

თუ დადგინდა რომ ფრაგნენტირებული და შენაერთი პაკეტები მისაღებად ითვლება და სწორედ ხარისხდება მსხვერპლის მიერ და ფაირვოლი მას არ ბლოკავს ან სხვა დამცველი მექანიზმი, მაშინ შეგვიძლია fragroute-ის გამოყენება მთელი IP ტრეფიკის ფრაგმენტირება შეგვიძლია მსხვერპლი სერვერის წინააღმდეგ.

# fragroute

fragroute-ი იჭერს, ცვლის, და ხელახლად წერს egress ტრეფიკს რომელიც გამიზნულია სხვა კომპიუტერისთვის, წინასწარ დეკლარირებული წესების მიხედვით.

კონფიგურების ფაილებია:

```
/usr/local/sbin/fragtest
/usr/local/sbin/fragroute
/usr/local/etc/fragroute.conf
```

fragroute.conf-ში აღწერილია fragroute-მა როგორ უნდა დააფრეგნაბტოს, დააყოვნოს (delays), გააუქმოს (drops), შექმნას დუპლიკატი, სეგმენტებად გაყოს, შერწყმას, და გაჩეხოს გასაგზავნი IP ტრეფიკი.

```
# cat /usr/local/etc/fragroute.conf

tcp_seg 1 new

ip_frag 24

ip_chaff dup

order random

print
```

```
# fragroute

Usage: fragroute [-f file] dst
```

```
# fragroute 192.168.102.251

fragroute: tcp_seg -> ip_frag -> ip_chaff -> order -> print
```

თუ print-ი არის აღნიშნული fragroute.conf-ში მაშინ დამუშავებული egress ტრეფიკი ეკრანზე იბეჭდება tcpdump-ის ფორმატში.
თავისთავად კონფიგურაციით, TCP მონაცემები დაყოფილია 1-ბაიტიან სეგმენტებად და IP მონაცემები კი 24-ბაიტიან მონაცემებათ, ეს ყველაფერი IP დაჩეხვის და გასაგზავნი პაკეტების ჰაზარტულად დალაგებასთან ერთად.

### fragroute.conf

რომ გაეცნოთ ცვლადებს რომლებიც აღწერილია fragroute.conf-ში:

```
# man fragroute
```

მაგალითი 1:

```
ip_frag 8 old # 8 ბაიტებად დაყოფა, უპირატესობა ეძლევა ძველ მონაცემებს

order random # ჰაზარტულად ხელახლად დალაგება

print # ბეჭდავს
```

მაგალითი 2:

```
tcp_seg 4 new  # TCP მონაცემები სეგმენტირებულია 4 ბაიტებად

tcp_chaff paws # უპირატესობა ეძლევა ახალ მონაცემებს, დაყოფის და შერევის შემდეგმ ძველი დროის ნიმუშის გამოყენებით, PAWS-ის გაუქმებისთვის.

order random   # ჰაზარტულად ხელახლად დალაგება

print
```

შესაძლოა ზოგმა სერვერმა კრაში განიცადოს ხოლმე ფრაგმენტირებული პაკეტების დამუშავების გამო.

## nmap

nmap-ს შეუძლია პაკეტების ფრაგმენტირება half-open SYN ან inverse TCP სკანირების დროს. ამ მომენტში TCP header-ი დაყოფილია მრავალ პაკეტად რომ  გართულდეს ფაირვოლებისგან და IDS-ებისგან პორტ სკანირების დეტექტირება.

Half-open SYN TCP სკანირება ფრაგმენტირებული პაკეტებით:

```
nmap -sS -f 192.168.102.251

Starting nmap 3.45 ( www.insecure.org/nmap/ )

Interesting ports on cartman (192.168.102.251):

(The 1524 ports scanned but not shown below are in state: closed)

Port       State       Service

25/tcp     open        smtp

53/tcp     open        domain

8080/tcp   open        http-proxy


Nmap run completed -- 1 IP address (1 host up) scanned in 0 seconds
```



# დაცვა

არსებობს ფაირვოლები რომლებიც IP ფრაგმენტს რიგში ინახავენ და შემდეგ ახარისხებენ პაკეტებს,
მაგრამ ზოგიერთი ამ ფუნქციას აუქმებს ამ პროცესისგან რესურსების მოთხოვნის გამო.

## მრავალი შემტევი კომპიუტერის სიმულაცია

ჰაკერის IP მისამართი ძნელად დასადგენი ხდება მრავალი გაყალბებული (spoofed) IP მისამართის გამოყენებით.

nmap-ის პარამეტრი რომელიც მიუთითებს გაყალბებულ სატყარა მისამართებს არის -D [გაყალბებული1,ME,გაყალბებული2,გაყალბებული3,...].

nmap-ის გამოყენება სკანირებისთვის გაყალბებული მისამრთებით:

```
# nmap -sS -P0 -D 62.232.12.8,ME,65.213.217.241 192.168.102.251


Starting nmap 3.45 ( www.insecure.org/nmap/ )

Interesting ports on cartman (192.168.102.251):

(The 1524 ports scanned but not shown below are in state: closed)

Port       State       Service

25/tcp     open        smtp

53/tcp     open        domain

8080/tcp   open        http-proxy

Nmap run completed -- 1 IP address (1 host up) scanned in 0 seconds
```

-P0: ping-ის გაუქმება, სკანირება სტელსური რომ იყოს, ICMP echo request-ები და TCP კავშირის დამყარების ცდილობები არ უნდა განხორციელდეს თორე შემტევის IP მისამართი დაფიქსირდება.


## წყარო მარშუტის გამოყენება

წყარო მარშუტის გამოყენება (source routing) წესით ქსელის დიაგნოსტიკისთვის იხმარება.
მაგალითად შეგვიძლია traceroute-ს მივანიშნოთ პაკეტებმა რომელი gateway-ები გადალახონ (loosely ან strictly routed through) რომ სპეციფიკური მარშუტები შემოწმდეს.
წყარო მარშუტის გამოყენება გვაძლევს საშუალებას gateway-ები რომლებიც გვურს რომ ჩვენმა პაკეტებმა გადალახონ, ვიდრე როუტერებმა თვითონვე დაადგინონ და შეარჩიონ გზა.

წყარო მარშუტის ინფორმაცია არის მოცემული როგორც IP პარამეტრი, პაკეტის header-ში.

IP პარამეტრების მონაცემთა ფორმატი, წყარო მარშუტზე დამოკიდებულ (source-routed) პაკეტში, საკმაოდ მარტივია.
პირველი სამი ბაიტი ეკუთვნის IP პარამეტრების კოდს, სიგრძეს, და მაჩვენებელს. იმიტომ რომ IP მონაცემის გამოყენება შესაძლოა სხვადასხვა ფუნქციისთვის, (დროის ნიშნული (timestamp), მკაცრი მარშუტიზაცია (strict routing), მარშური (route), და ჩანაწერი (record)), კოდის სფერო (code field) განსაზღვრავს პარამეტრის ტიპს.
სიგრძის სფერო, რაც უნცნაური არ უნდა იყოს, მიანიშნებს პარამეტრების მონაცემთა ზომას, რაც ვერ აღემატება 40 ბაიტს. 
საბოლოოდ, განსხვავების (offset) მაჩვენებლის სფერო, მიგვანიშნებს მიმდინარე IP მისამართს დარჩენილი მონაცემების განყოფილებაში, რომელიც განახლდება როდესაც პაკეტი ინტერნეტში "შედის".

ორ ნაირი source routing-ი არსებობს, ორივე აღწერილია RFC 791-ში:

  * Strict Source and Route Record (SSRR)
  * Loose Source and Route Record (LSRR)

Loose source routing-ით დაშვებულია რომ პაკეტმა გაიაროს რამოდენიმე შუამავალი gateway-ები რომ გზის შემდეგ მისამართს მიაღწიოს.
Strict source routing-ით კი აუცილებელია რომ გზის შემდგომი მისამართი პირდაპირ იყოს დაკავშირებული ქსელთან; თუ არა და, პაკეტი ვერ მიაღწევს.

წყარო მარშუტის პარამეტრებს აქვთ ცვლადი სიგრძე, რომელიც შეიცავს მთელ რიგ IP მისამართებს და offset-ის მაჩვენებელს რომელიც მიათითებს შემდეგ IP მისამართს რომელიც უნდა დამუშავდეს.

წყარო მარშუტიანი (source-routed) დატაგრამი მიწოდებას ასრულებს როცა offset-ის მაჩვენებელი მიუთითებს ბოლო სფეროს და მიმღების IP მისამართის შემდგომ.

IP პარამეტრის სფეროში, როუტერის მონაცემები 40 სიმბოლოომდეა ლიმიტირებული. 3 ბაიტი გამოიყენება header-ის ინფორმაციისთვის და 4 ბაიტი მასპინძლის მისამართისთვის, რაც ტოვებს 33 ბაიტს რომ განსაზღვროთ loose hop-ები, ანუ 8 მისამართის მითითება შეგვიძლია hop-ების (ნახტომები) სიაში (საბოლოო მისამართის ჩაუთვლელად).

წყარო მარშუტის სისუსტეების ექსპლუატაცია შეგვიძლია შემდეგი ხერხებით:

  * წყარო მარშუტის გაუკუღმება
  * ფილტრების (ანუ ფაირვოლებისაც) მოტყუება და შიდა ქსელთან მიწვდომა 
	

თუ ფაირვოლი ან gateway წყარო მარშუტს აუკუღმებს პაკეტებით პასუხის გაცემის დროს, მაშინ შეგიძლია ტრეფიკის სნიფინგი ერთ-ერთი მასპინძლის მისამართზე რომელიც შენ მიუთითე. როგორც სნიფერზე დაფუძნებულ სპუფირებულ (გაყალბებულ) სკანირების შემთხვევაში, შეგიძლია სკანირების განხორციელება პოტენციალურად სანდოდ მიჩნეული კომპიუტერიდან.

## წყარო მარშუტის სისუსტეების დადგენა

lsrscan: http://www.synacklabs.net/projects/lsrscan/

lsrtunnel: http://www.synacklabs.net/projects/lsrtunnel/

დოკუმენტი რომელშიც ახსნილია წყარო მარშუტთან დაკავშირებულ პრობლემებს: http://www.synacklabs.net/OOB/LSR.html.


### lsrscan

lsrscan-ი ხელოვნურად ქმნის პაკეტებს წყარო მარშუტის პარამეტრებით რომ დაადგინონ როგორ ახარისხებს სერვერი წყარო მარშუტიან პაკეტებს. 

lsrscan-ი ეძებს 2 რამეს:

  * მიზანში ამოღებული კომპიუტერი თუ მიმართულებას უცვლის წყარო მარშუტს (source route) როცა პაკეტებს უკან აგზავნის.
  * მიზანში ამოღებული host-ს თუ შეუძლია forward source-routed პაკეტების შიდა host-ისთვის გაგზავნა, offset მაჩვენებლისთვის loose hop სიაში მითითებული ნახტომების (hops) რაოდენობაზე მეტი ნომერის მინიჭებითT.


გამოყენება:

```
# lsrscan

usage: lsrscan [-p dstport] [-s srcport] [-S ip]

               [-t (to|through|both)] [-b host<:host ...>]

               [-a host<:host ...>] <hosts>
```

ზოგი ოპერაციულ სისტემებში reverse source-routed ტრეფიკს მხოლოთ ღია პორტებისთვის, ამიტომ lsrscan-ით ღია პორტი უნდა შეამოწმოთ, default-ი პორტი 80-ია.
წყარო პორტი და წყარო IP მისამართი არ არის საჭირო (lsrscan-ი random-ლად ირჩევს წყარო პორტს IP-ს) მაგრამ შეიძლება ზოგჭერ გამოდგეს.

  * -b : წყარო მარშუტის (source route) სიაში ათავებს IP მისამართებს, ჰაკერის მისამართის წინ, რომლებიც უნდა გაიაროს მსხვერპლის კომპიუტერამდე.
  * -a : IP მისამართები შეაქვს მომხმარებლის host-ის შემდეგ, სიაში  (ამ host-ებს უნდა შეეძლოთ source route forwarding რომ სკანირება ეფექტური იყოს).

მეთი ინფორმაციისთვის:

```
# man lsrscan
```

lsrscan-ით წყარო მარშუტთან დაკავშირებული პრობლემების დადგენა

```
# lsrscan 217.53.62.0/24

217.53.62.0 does not reverse LSR traffic to it

217.53.62.0 does not forward LSR traffic through it

217.53.62.1 reverses LSR traffic to it

217.53.62.1 forwards LSR traffic through it

217.53.62.2 reverses LSR traffic to it

217.53.62.2 does not forward LSR traffic through it
```

იმიტომ რომ ზოგი სისტემა აუკუღმებს წყარო მარშუტს, სპუფირებით ( spoofing) შეტევა შესაძლოა lsrtunnel-ით.
იმიტომ რომ სისტემები forward source-routed ტრეფიკს, ქსელის შიდა IP მისანართები ზუსტად უნდა იყოს დადგენილი რომ ქსელის სკანირება განხორციელდეს fragroute-ით.

# lsrtunnel

lsrtunnel-ი სპუფავს (spoofing) კავშირს source-routed პაკეტებით. ამ ხელსაწყომ იმუშავოს მიზანში ამოღებულმა host-მა უნდა reverse the source route (თორე ვე ნახავთ პასუხებს და ვერ შეძლებთ მთლიანად სპუფოთ  TCP კავშირი).
lsrtunnel სჭირდება სათადარიგო IP მისამართი ლოკალურ ქსელში რომ იგი იხმაროს როგორც პროქსი მიზანში ამოღებულ host-თან კავშირისთვის.

გამოყენება:

```
# lsrtunnel

usage: ./lsrtunnel -i <პროქსის IP> -t <მსხვერპლის IP> -f <გაყალბებული IP>
```

  * პროქსის IP: IP რომელიც არ იხმარება, ეს ითამაშებს პროქსის როლს.
  * გაყალბებული IP: IP რომელიც ფიქსირდება როგორც კავშირის დამყარებლის მისამართი.

ზედმეტი ინფორმაციისთვის:

```
# man lsrtunnel 
```

lsrtunnel-ის გამოყენება, 192.168.102.2 და მსხვერპლი იგივე ქვექსელში არიან:

```
# lsrtunnel -i 192.168.102.2 -t 217.53.62.2 -f relay2.ucia.gov
```

ამ ეტაპზე, lsrtunnel-ი ელოდება ტრეფიკს პროქსის IP მისამართზე (192.168.102.2).  რაც მისდის პროქსის სინამდვილეში მისდის დამიზნულ host-ს (217.53.62.2) და ისე ფიქსირდება ვითომ პაკეტები relay2.ucia.gov-დან მოდის.


## სპეციფიკური TCP და UDP წყარო პორტების გამოყენება


როცა იყენებ ხელსაწყოს როგორიცაა მაგალითად nmap-ი UDP ან TCP პორტ სკანირებისთვის (UDP, half-open SYN, inverse FIN scan), შეგიძლია მიუთითოთ წყარო პორტები სკანირების დროს ფაირვოლის გადალახვის ეფექტურობისთვის.

4 პრაქტიკული პორტი რომლებიც შეგიძლია გამოიყენო:

  * TCP და UDP პორტი 53 (DNS)
  * TCP პორტი 20 (FTP მონაცამებისთვის)
  * TCP პორტი 80 (HTTP)
  * TCP და UDP პორტი 88 (Kerberos)

გარკვეული წყარო პორტის ნომრების გამოყენებით, ჰაკერს შეუძლია რომ ცუდად კონფიგურირებული ფაირვოლი მოატყუოს. ამისთვის UDP პორტი 53 (DNS) კარგია, stateless packet filters გადასალახვად, იმიტომ რომ ბევრგან დაშვებულია გარე DNS სერვერებთან კავშირისთვის, პასუხი კი პორტ UDP 53-ზე უნდა მოვიდეს.
ფაირვოლის წესი არის ასეთი: დაუშვი ტრეფიკი UDP პორტ 53-დან 53-მდე, ან პორტები რომლებიც 1024-ს აღემატებიან.

stateful ფაირვოლები დაცულნი არიან ამ ტექნიკის წინააღმდეგ (თუ ცუდად არ არიან კონფიგურირებულნი) იმიტომ რომ ისინი ინახავენ ქსელური ლავშირის სტატუსს, და პასუხის გაცემა დაშვებულია მხოლოდ იმ შემთხვევაში თუ კავშირი უკვე დამყარებუი იქნა.

გაეცანით დოკუმენტს რომელიც დაიბეჭდა Black Hat Briefings 2000-ისთვის "A Stateful Inspection of Firewall-1": http://www.blackhat.com/html/bh-usa-00/bh-usa-00-speakers.html.

nmap-ის გამოყენება წყარო პორტების მითითებით სკანირების დროს:

პარამეტრი -g საშუალებას იძლევა რომ half-open TCP SYN პორტ სკანირება განხორციელდეს, რომელიც ხმარობს წყარო პორტ 88-ს.

```
# nmap -sS -g 88 192.168.102.250


Starting nmap 3.45 ( www.insecure.org/nmap/ )

Interesting ports on kenny (192.168.102.250):

(The 1528 ports scanned but not shown below are in state: closed)

Port       State       Service

7/tcp      open        echo

9/tcp      open        discard

13/tcp     open        daytime

17/tcp     open        qotd

19/tcp     open        chargen

21/tcp     open        ftp

25/tcp     open        smtp

42/tcp     open        nameserver

53/tcp     open        domain

80/tcp     open        http

88/tcp     open        kerberos-sec

135/tcp    open        loc-srv

139/tcp    open        netbios-ssn

389/tcp    open        ldap

443/tcp    open        https

445/tcp    open        microsoft-ds

464/tcp    open        kpasswd5

515/tcp    open        printer

548/tcp    open        afpovertcp

593/tcp    open        http-rpc-epmap

636/tcp    open        ldapssl

1026/tcp   open        nterm

2105/tcp   open        eklogin

6666/tcp   open        irc-serv


Nmap run completed -- 1 IP address (1 host up) scanned in 1 second
```
