# თეორია

პორტ სკანირება საშუალებას გვაძლევს რომ დავადგინოთ ღია პორტები რომლებზეც სერვისებია გაშვებული. პორტის ორნაირი სახეობა არსებობს: UDP და TCP.
იუნიქსში პორტების ნომრები და მითი სტანდარტული სერვისები არის აღწერილი ფაილ /etc/services-ში.

## TCP სკანირების სახეობები

სტანდარტული სკანირების მეთოდები:

  * პირდაპირი კავშირით სკანირება (direct connect scanning)
  * Half-open SYN flag scanning

სტელსური TCP სკანირების მეთოდები:

  * Inverse TCP flag scanning
  * ACK flag probe scanning
  * TCP fragmentation scanning

მესამე პირის მიერ და სპუფირებული (spoofed) TCP სკანირების მეთოდები:

  * Proxy bounce scanning
  * Sniffer-based spoofed scanning
  * IP ID header scanning

# UDP პორტების სკანირება

## თეორია

UDP-ს სკანირება იმ შემთხვევაში შეიძლება იმ შემთხვევაში თუ ICMP type 3 code 3 მესიჯებით პასუხის გაცემა დაშვებულია ფაირვოლის მიერ.

UDP არის უკავშირო პროტოკოლი, ამიტომ მხოლოდ 2 ვარიანტია რომ გავიგოთ UDP პორტი ღიაა თუ არა:
  * UDP პაკეტის გაგზავნა UDP პორტზე, და დალოდება "ICMP destination port unreachable" მესიჯისთვის დახურული პორტების დასადგენად.
  * UDP-ზე დაფუძნებული სერვისის კლიენტის გამოყენება(მაგალითად snmpwalk, dig, ან tftp) UDP datagram-ების გასაგზავნად მსხვერპლის UDP პორტებზე და დადებითი პასუხის ლოდინი.


**უკუღმა UDP პორტ სკანირების რეზულტატი როცა სკანირებული პორტი ღიაა.**

UDP პორტ სკანირება არის უკუღმა სკანირების ტიპის, თუ პორტი ღიაა მაშინ პასუხი უკან არ ბრუნდება. ყურადღება მახვილდება "ICMP destination port
unreachable" (type 3 code 3) მესიჯებზე მიზანში ამოღებული host-იდან მოსულ პაკეტებისგან, როგორცაა ნაჩვენები შემდეგ ფიგურაზე.


**უკუღმა UDP პორტ სკანირების რეზულტატი როცა სკანირებული პორტი დახურულია.**

## პრაქტიკა

nmap-ს და Foundstone-ოს (მხოლოდ ვინდოუსი) SuperScan-საც შეუძლია UDP სკანირება მაგრამ ორივე ელოდება
"ICMP destination port unreachable" მესიჯებს ღია პორტების დასადგენად (ანუ პორტები რომლებიც არ პასუხობენ).
თუ ფაირვოლის მიერ ICMP მესიჯები ფილტრირებულია მაშინ რეზულტატი არაზუსტი იქნება.

### ლინუქსში და ვინდოუსში

```
# nmap -sU 123.65.34.8
```

### ვინდოუსში

#### scanudp

scanudp (http://www.oocities.org/fryxar/) არის ხელსაწყო პოპულარულ UDP სერვისების პორტებზე აგზავნის ხელოვნურად შექმნილ UDP პაკეტებს და ელოდება დადებით პასეხებს.

```
./scanudp

./scanudp v2.0 -   by: Fryxar

usage: ./scanudp [options] <host>

options:

 -t <timeout>     Set port scanning timeout
 -b <bps>         Set max bandwidth
 -v               Verbose
```


მხარდაჭერილი პროტოკოლებია: echo daytime chargen dns tftp ntp ns-netbios snmp(ILMI) snmp(public)


IP-ს UDP პორტების სკანირება

```
# ./scanudp 123.65.34.8
```


## დაცვა

ICMP მესიჯების ბლოკირება ფაირვოლით.

# TCP პორტების სკანირება

სკანირების სტანდარტული მეთოდები, როგორიცაა პირდაპირი კავშირით და half-open SYN სკანირება, არიან უმარტივესი და საიმედო მაგრამ ამიტომაც ასეთი სკანირების დეტექტირება და ლოგ ფაილებში დაფიქსირება ადვილია.

## სტანდარტული სკანირების მეთოდები

### პირდაპირ კავშირით სკანირება (direct connect scanning)

TCP connect() მეთოდით პორტ სკანირება ყველაზე მარტივია. იგი სტელსის გარეშეა იმიტომ რომ სრულყოფილ TCP/IP კავშირი მყარდება მიზანში ამოღებული host-ის გარკვეულ პორტზე.

ეს მეთოდი სანდოა იმიტომ რომ TCP პროტოკოლით კავშირის დროს დაკარგული პაკეტები თავიდან იგზავნება.


**TCP connect() მეთოდით პორტ სკანირების რეზულტატი როცა პორტი ღიაა.**


**როდესაც TCP connect() მეთოდით ვასკანირებთ პორტს და პორტი დახურულია მაშინ მოგვდის RST/ACK პაკეტი.**

#### იუნიქსი და ვინდოუსი

```
# nmap -sT 145.33.54.28
```

#### იუნიქსი

  * pscan.c (http://www.packetstormsecurity.org)

#### ვინდოუსი

  * Foundstone's SuperScan: http://www.foundstone.com/knowledge/scanning.html


### Half-open SYN flag scanning

ორი host-ის კავშირის სინქრონიზაციისთვის "სამ-ფაზიანი ხელისჩამორთმევა" არის საჭირო.

  - კლიენტი სერვერს უგზავნის SYN პაკეტს გარკვეულ პორტზე.
  - სერვერი კლიენტს პასუხობს SYN/ACK პაკეტით თუ პორტი ღიაა.
  - კლიენტი სერვერს უგზავნის ACK პაკეტს რომ "სამ-ფაზიანი ხელჩამორთმევა" დაასრულოს.

Half-open SYN პორტ სკანირების შემთხვევაში გარკვეულ ღია პორტზე იგზავნება RST პაკეტი "სამ-ფაზიან ხელჩამორთმის" მესამე ფაზაში. RST პაკეტის ამ დროს გაგზავნა იწვევს TCP კავშირის უხეშად გამოთიშვას, რაც საშუალებას არ აძლევს "სამ-ფაზიანი ხელჩამორთვის" პროცეს რომ ბოლომდე დასრულდეს, და ამიტომაც ხშირ შემთხვევაში კავშირის დამყარების მცდელობა არ არის შეტანილი მსხვერპლის ლოგ ფაილში.

SYN სკანირება სწრაფია და სანდო რეზულტატებს იძლევა მაგრამ მის განხორციელებას სჭირდება raw socket-ები და აქედან გამომდინარე მაღალი პრივილეგები, root-ი იუნიქსისნაირ სისტემაში, ვინდოუსში კი Administrator-ი.

თუ ქსურთ რომ პორტ სკანირება (სტელსი) დამალულად შეასრულოდ მაშინ უნდა გამოიყენოთ ტექნიკები როგორიცაა FIN ან TTL-ზე დაფუძნებული სკანირება, ან საერთოდ გამოიყენოთ ხელსაწყო fragroute-ი, გაგზავნილი პაკეტების ფრაგმენტირებისთვის.


**Half-open SYN პორტ სკანირების რეზულტატი როცა სკანირებული პორტი დახურულია.**

სქემის ახსნა: როგორც ვხედავთ როცა პორტ დახურულია მაშინ მოგვდის RST/ACK პაკეტი. Half-open syn სკანირების უპირატესობა ისაა რომ რახან  three-way TCP handshake არ სრულდება ბოლომდე, კავშირი არა დამყარებულად ითვლება და ამიტომაც ლოგ ფაილშიც არ ფიქსირდება.


**Half-open SYN პორტ სკანირების რეზულტატი როცა სკანირებული პორტი ღიაა.**

სქემის ახსნა: ვაგზავნით SYN პაკეტს სერვერის პორტზე; მოგვდის SYN/ACK პაკეტი რაც სინშნავს რომ პორტი ღიაა. წესით ამ ეტაპზე, connect() სკანირების დროს მოგვდის ACK პაკეტი კავშირის დასამყარებლად, მაგრამ ეს არის half-open syn სკანირება, და ამიტომ RST იგზავნება რომ კავშირი ბოლომდე ვერ დამყარდეს.

#### იუნიქსი და ვინდოუსი

თუ SYN პაკეტებს ჩქარჩქარა აგზავნით შესაძლოა ფაირვოლებმა ეს არ დაუშვან, იმიტომ რომ დაამსგავსებენ SYN flood-თან, ეს რომ არ მოხდეს და სკანირება არ დაიბლოკოს შეგიძლია nmap-ს მიუნიშნოთ რომ სკანირების შორი რაიმე ვადა გავიდეს რომ ქსელური ნაკადი ნაკლებად უხეში იყოს, ამისთვოს nmap-ს მიუთითეთ -T.

```
# nmap -sS 43.87.33.67
```

```
# strobe
```

#### იუნიქსი

scanrand-ი არის Paketto Keiretsu suite-ის ერთერთი კომპონენტი.
იგი იყენებს უკუღმა SYN ქუქიებს (HMAC SHA1 ჰეშირების ალგორითმით), გაგზავნილი პაკეტების ტეგირებისთვის რომ false positive-ები აღარ არსებობდეს (მხოლოდ აღიქვამს სწორი კრიპტოგრაფიული ქუქიებით დამახასიათებელ SYN/ACK საპასუხო პაკეტებს).
მას ქსელის მთლიანად სკანირებისთვის საგრძნობლად ნაკლები დრო სჭირდება ვიდრე მაგალითად nmap-ს.

scanrad-ი ბევრ SYN პაკეტს აგზავნის და შემდეგ ელოდება დადებით SYN/ACK პასუხებს, ამიტომაც იგი პორტების სტატუს (ღიაა თუ არა) მაინცდამაინც მიმდევრობით არ ადგენს. სამაგიეროდ სწრაფია.

საიტი: http://www.doxpara.com/read.php/code/paketto.html.

```
# scanrand 76.0.1.1-254:quick
```

#### დაცვა

უმეტეს intrusion detection system-ებს (IDS), პერსონალურ ფაირვოლებს და სხვა დამცველ პროგრამებს, როგორც, portsentry, შეუძლიათ half-open SYN პორტ სკანირების დეტექტირება და გაუქმება.
ზოგჯერ შეიძლება იგი შეეშალოთ SYN flood-თან იმიტომ რომ ამ ტიპის სკანირებას ბევრი SYN პაკეტის გაგზვნა ახასიათებს.

## სტელსური TCP სკანირების მეთოდები

პორტ სკანირების სტელსური მეთოდები მოქმედებენ მახვილი გაგებით თუ როგორ ახარისხებს პაკეტებს ან პასუხობს არა სტანდარტულად დამზადებულ (ზოგიერთი ბიტის გააქტიურება/გაუქმება, feature-ის გააქტიურება/გაუქმება) პაკეტებს მსხვერპლის ოპერაციული სისტემის TCP/IP stack-ი. ასეთი ტექნიკები არ არიან სანდო ღია პორტების ზუსტად დასადგენად მაგრამ სამაგიეროთ სტელსურია და მსხვერპლის მოგ ფაილში შესაძლოა არ დაფიქსირდეს სკანირების მცდელობა.

### Inverse TCP flag scanning

სკანირება ხელოვნურად შექმნილი (TCP flag-ების გააქტიურა/გაუქმება) პაკეტების გაგზავნით შესაძლოა ფაირვოლი გადალახოს, გააჩნია ფაირვოლის წესებს.

Half-open SYN პორტ სკანირება არის ცნობილი როგორც "უკუღმქ ტექნიკა" იმიტომ რომ პასუხები მხოლოდ დახურული პორტის შემთხვევაში მოდის. RFC 793-ის მიხედვით თუ მიზანში ამოღებულ host-ზე პორტი დახურულია, მაშინ RST/ACK პაკეტი უნდა გაეცეს საპასუხოდ რომ კავშირი ახლიდან დამყარდეს (reset).
ამიტომ ჰაკერები TCP პაკეტებს აგზავნიან სხვადასხვა TCP flag-ებით გააქტიურებული.

გამოყენებულ პაკეტებში, პაკეტების flag-ების 3 ვარიანტია:
  * FIN სკანირება, პაკეტში FIN TCP დროშაა გააქტიურებული
  * XMAS სკანირება, პაკეტში FIN, URG, და PUSH TCP დროშებია გააქტიურებული
  * NULL სკანირება, არცერთი TCP დროშაა გააქტიურებული


**Inverse TCP პორტ სკანირების რეზულტატი როცა სკანირებული პორტი ღიაა.**


**Inverse TCP პორტ სკანირების რეზულტატი როცა სკანირებული პორტი დახურულია.**

RFC-ს მიხედვით, თუ პასუხი უკან არ მოვიდა მაშინ პორტი ღიაა, ან სერვერი გამორთულია. მაინცდამაინც სანდო მეთოდი არ არის მაგრამ სტელსურია.

**შენიშვნა:** ვინდოუსი RST/ACK პაკეტით არ პასუხობს თუ პორტი დახურულია იმიტომ რომ RFC 793-ის მხარდაჭერა არა აქვს. ამიტომაც ეს ტექნიკა უფრო იუნიქსისნაირ ოპერაციულ სისტემებზეა ეფექტური.

#### იუნიქსი და ვინდოუსი

მხოლოდ FIN flag-ით სკანირება:

```
# nmap -sF 143.76.3.2
```

არცერთი flag-ი არ არის გააქტიურებული (NULL scan):

```
# nmap -sN 143.76.3.2
```

ყოველივე flag-ი გააქტიურებულია (Xmas tree scan)

```
# nmap -sX 143.76.3.2
```

#### ვინდოუსი

vscan ხმარობს raw socket-ებს Winsock 2-ის მეშვეობით. http://host.deluxnetwork.com/~vsniff/vscan.zip.

#### დაცვა

ფაირვოლებს და IDS-ებს შეუძლიათ SYN პაკეტების დეტექტირება. პროგრამებს როგორიცაა synlogger და courtney შეუძლიათ half-open SYN flag პორტ სკანირების დეტექტირება.

### ACK flag probe scanning

ეს ტექნიკა გამოქვეყნებული იქნა Phrack Magazine-ში, Issue 49, ღია პორტებს ადგენს ACK პაკეტების გაგზავნით და შემდეგ ანალიზებს გამოგზავნილი RST პაკეტის header-ს.  ეს სისუსტე მხოლოდ BSD TCP/IP stack-ის და მასზე დაფუძნებულ TCP/IP stack-ებს ახასიათებთ.
ACK სკანირების 2 მეთოდია:
  * მიღებული პაკეტის TTL (time-to-live) field-ის ანიზი
  * მიღებული პაკეტის WINDOW field-ის ანალიზი

ამ ტექნიკით შესაძლოა გავარკვიოთ ქსელში რა პროცესით ფილტრილდება (ან ხარისხდება) პაკეტები. მაგალითად, TTL-ი გვაჩვენებს რამდენი სისტემა გადალახა პაკეტმა. მსგავსი მეთოდით მოქმედებს firewalk-იც, ფილტრაციის ანალიზის ხელსაძწყო, http://www.packetfactory.net/projects/firewalk/.

#### მიღებული პაკეტების TTL განყოფილების ანალიზი

მიღებული RST პაკეტების TTL field-ის ანალიზისთვის, ჰაკერი ჯერ ათასობით ხელვნურად შექმნილ ACK პაკეტს აგზავნის სხვადასხვა TCP პორტებზე.


**ACK პაკეტები იგზავნება სხვადასხვა პორტებზე.**

მიღებული პირველი პაკეტები, hping2-ის ლოგი:

```
1: host 192.168.0.12 port 20: F:RST -> ttl: 70 win: 0
2: host 192.168.0.12 port 21: F:RST -> ttl: 70 win: 0
3: host 192.168.0.12 port 22: F:RST -> ttl: 40 win: 0
4: host 192.168.0.12 port 23: F:RST -> ttl: 70 win: 0
```

ვხედავთ რომ 22 პორტზე გაგზავნილი საპასუხო პაკეტის TTL-ი არის 40, სხვა პორტების კი 70. ეს მიგვანიშნებს რომ მსხვერპლს პორტი 22 ღია აქვს იმიტომ რომ საპასუხო პაკეტში TTL-ი 64-ზე პატარაა (64 TTL-ის საზღვარია).

#### მიღებული პაკეტების WINDOW განყოფილების ანალიზი

მიღებული RST პაკეტების WINDOW field-ის ანალიზისთვის, ჰაკერი ჯერ ათასობით ხელვნურად შექმნილ ACK პაკეტს აგზავნის სხვადასხვა TCP პორტებზე.

მიღებული პირველი 4 RST პაკეტი, hping2-ის ლოგი:

```
1: host 192.168.0.20 port 20: F:RST -> ttl: 64 win: 0
2: host 192.168.0.20 port 21: F:RST -> ttl: 64 win: 0
3: host 192.168.0.20 port 22: F:RST -> ttl: 64 win: 512
4: host 192.168.0.20 port 23: F:RST -> ttl: 64 win: 0
```

რახან მიღებული პაკეტების TTL-ი 64-ს უდრის (64 TTL-ის საზღვარია), TTL-ის ანალიზი ეფექტური არ არის ღია პორტების დასადგენად. სამაგიეროთ, WINDOW field-ის value-ს ანალიზით, შეგვიძლია დავადგინოთ რომ მესამე პაკეტის WINDOW field-ის value 0 არ არის, რაც მიგვანიშნებს ღია პორტს.

ACK სკანირების აღმოჩენა ძნელია, (IDS-ებისთვის და პერსონალური ფაირვოლებისთვისაც). ეს ტექნიკა TCP/IP stack-ის ბუგებს იყენებს, რომლებიც გარკვეული რაოდენობით არსებობენ BSD-ზე დაყრდნობილ TCP/IP stack-ებზე სხვა იმპლემენტაციების განსხვავებით.

##### იუნიქსი და ვინდოუსი

TTL-ების ანალიზი

```
# nmap -sA 34.11.7.3
```

WINDOW value-ების ანალიზი

```
# nmap -sW 34.11.7.3
```

##### იუნიქსი

hping2-საც შეუძლია TTL-ების და WINDOW value-ების ანალიზი, მაგრამ ამ საქმისთვის უფრო ნელია.
hping2-ი უფრო low-level დეტალებისთვისაა გამიზნული, სკანირების განსხვავებით.

საიტი: http://www.eaglenet.org/antirez/hping2.html ან http://www.hping.org.


## მესამე მხარის და Spoofed TCP სკანირების მეთოდები

მესამე პირის ტიპის პორტ სკანირება ხდება გატეხილი სერვერის გამოყენების საშუალებით, სინამდვილეშო გატეხილი სერვერი ასკანირებს პორტებს და არა ჰაკერის კომპიუტერი, რაც მას მალავს. კიდე ის არის კარგი რომ ფაირვოლის კონფიგურაციის მოპოვება შეიძლება სკანირების ჩატარებით გატეხილი სერვერიდან რომელის ფაირვოლილის მიერ უშიშოთ მიიჩნევა.

### Proxy bounce სკანირება

თუ პროქსის სერვერი ცუდადაა კონფიგურირებული მაშინ TCP პაკეტებს გაატარებს.
პროქსით სკანირება ნელია, ამავე დროს ბევრ ჰაკერს ურჩევნია პირდაპირ თავდასხმაც პროქსის მეშვეობით აწარმოოს.
  * http://www.dsinet.org/tools/network-scanners/ppscan.c
  * http://www.phreak.org/archives/exploits/unix/network-scanners/ppscan.c

### სნიფერზე დაყრდნობილი სპუფინგით სკანირება

spoofscan-ი აწარმოებს სტელსურ სკანირებას, half-open SYN TCP სკანირებაა,  ქსელის კარტის promiscuous რეჟიმში გადაყავს (root-ი უნდა იყო ამისთვის) და შემდეგ სნიფავს (sniffer) ლოკალურ ქსელში შემოსულ პაკეტებს.

ეს იძლევა 2 უპირატესობას:

  * თუ superuser-ი ხარ ერთერთ host-ში რომელიც ფიზიკურად იმავე ქსელის სეგმენტშია შეერთებული რომელშისაცაა სასხვერპლე სერვერი ან ფაირვოლი რომელიც იცავს სასხვერპლე სერვერს, მაშინ შესაძლოა TCP სკანირების სპუფინგი (spoofing) სანდო host-ების IP მისამართების გამოყენებით და აგრეთვე ფაირვოლის წესების დასადგენად

  * თუ გაქვს მიწვდომა დიდ გაყოფილ ქსელურ სეგმენტთან, შესაძლოა სკანირების სპუფირება (spoof) სხვა host-ების IP მისამართების გამოყენებით ან ისეთი IP მისამართებით რომლებიც ამ ქსელში არ არიან ნახმარნი. ამით შეიძლება განხორციელდეს distributed და სტელსური პორტ სკანირება.

**შენიშვნა:** ამ ტექნიკის გამოყენება switch-ed ქსელშიც შეიძლება ARP redirect სპუფინგის (spoofing) და სხვა ხერხების მეშვეობით.

http://examples.oreilly.com/networksa/tools/spoofscan.c


### IP ID header სკანირება

IP ID header სკანირება (აგრეთვე ცნობილი როგორც idle ან dumb scanning) არის სკანირები ხერხი რომელიც იყენებს ოპერაციული სისტემების TCP/IP stack-ის განსაკუთრებულ სხვაობებს. 3 host-ია საჭირო ამ ტიპის სკანირებისთვის:

  * host-ი რომლიდანაც სკანირება ხორციელდება
  * მსხვერპლი host-ი რომელიც სკანირდება
  * ზომბირებული ან idle host-ი (რომელიც სანდოთაა მიჩნეული მსხვერპლის ფაირვოლის მიერ, მაგალითად host-ები რომლებიც DMZ ზონაში იმყოფებიან), რომელიც სპუფირებული (spoofing) პაკეტებით პორტ სკანირდება, მსხვერპლის ღია პორტების დასადგენად.

IP ID header scanning-ი სტელსურია თავისი უჩინარი თვისებების გამო. ჰაკერები ან სკანირების ტექნიკას ხმარობენ, რომ დაადგინონ სანდო ურთიერთობები host-ებთან, ფაირვოლებთან და VPN gateway-ების შორის.


**IP ID header სკანირება და მონაწილე მხარეები.**

hping2 ადრე იხმარებოდა "ხელით" low-level TCP სკანირებისთვის, მაგრამ ბევრი დროც სჭირდება მითუმეტეს დიდი ქსელების ვარიანტში.

დოკუმენტი არსებობს რომელშIც ახსნილია hping2-ით IP ID header scanning-ი "ხელით" როგორ უნდა განახორციელოთ: http://www.kyuzz.org/antirez/papers/dumbscan.html.

#### იუნიქსი და ვინდოუსი

```
# nmap -sI <zombie host[:probe port]>
```

```
# nmap -P0 -sI 192.168.0.155 192.168.0.50
Starting nmap 3.45 ( www.insecure.org/nmap/ )
Idlescan using zombie 192.168.0.155; Class: Incremental
Interesting ports on  (192.168.0.50):

(The 1582 ports scanned but not shown below are in state: closed)

Port       State       Service
25/tcp     open        smtp
53/tcp     open        domain
80/tcp     open        http
88/tcp     open        kerberos-sec
135/tcp    open        loc-srv
139/tcp    open        netbios-ssn
389/tcp    open        ldap
443/tcp    open        https
445/tcp    open        microsoft-ds
464/tcp    open        kpasswd5
593/tcp    open        http-rpc-epmap
636/tcp    open        ldapssl
1026/tcp   open        LSA-or-nterm
1029/tcp   open        ms-lsa
1033/tcp   open        netinfo
3268/tcp   open        globalcatLDAP
3269/tcp   open        globalcatLDAPssl
3372/tcp   open        msdtc
3389/tcp   open        ms-term-serv

Nmap run completed -- 1 IP address (1 host up)
```

**ყურადღება:**
თუ nmap-ი  გაშვებული იქნა -P0 flag-ის გარეშე "მესამე პირის სკანირების" პირობებში, მაშინ ჰაკერის host-I თვითონვე ახორციელებს ICMP და TCP ping-ირებას მსხვერპლის host-ის მიმართ სანამ სკანირება დაიწყება; ეს კი შესაძლოა ფაირვოლში ან IDS-ში დაფიქსირდეს, თუ სწორედ არიან კონფიგურირებულნი.

#### ვინდოუსი

vscan: http://host.deluxnetwork.com/~vsniff/vscan.zip

# Unicornscan

Unicornscan-ი მონაცემებს აგროვებს კორელაციების დასადგენად.
მას აქვს შემდგომი შესაძლებლობები:
 * ასინქრონულად უმდგომარეო (stateless) TCP პორტ სკანირება.
 * ასინქრონულად უმდგომარეო (stateless) TCP ბანერების მოპოვება.
 * ასინქრონულად UDP პორტ სკანირება.
 * აქტიურად და პასიურად ოპერაციული სისტემის და სერვისების სახელწოდებების დადგენა.

Unicornscan-ი სწრაფია. შეგიძლიათ მიუთითოდ რამდენი პაკეტი უნდა გააგზავნის წუთში (packet per second, PPS). რაც უფორ მეტ პაკეტს გააგზავნის სკანირება მით უფრო სწრაფი იქნება მაგრამ იცოდეთ რონ ქსელს ძალიან დათვირთავს და შესაძლოა მწყობრიდან გამოიყვანოს ზოგიერთი დანადგარი. PPS-ის დეფოლტია 300.


განვხორციელოთ დანადგარის (192.168.1.254) პორტ სკანირება UDP-თი (-m U), ისე რომ რეზულტატი ეგრევე აჩვენოს (-Iv), შეამოწმოს პორტები 1-დან 65535-მდე.

```
# unicornscan -m U -Iv 192.168.1.254:1-65535
adding 192.168.1.254/32 mode `UDPscan' ports `1-65535' pps 300
using interface(s) wlan0
scaning 1.00e+00 total hosts with 6.55e+04 total packets, should take a little longer than 3 Minutes, 45 Seconds
UDP open 192.168.1.254:5353  ttl 255
UDP open 192.168.1.254:53  ttl 64
UDP open 192.168.1.254:137  ttl 64
UDP open 192.168.1.254:67  ttl 64
UDP open 192.168.1.254:1900  ttl 64
sender statistics 299.6 pps with 65544 packets sent total
listener statistics 52 packets recieved 0 packets droped and 0 interface drops
UDP open	          domain[   53]		from 192.168.1.254  ttl 64
UDP open	          bootps[   67]		from 192.168.1.254  ttl 64
UDP open	      netbios-ns[  137]		from 192.168.1.254  ttl 64
UDP open	            ssdp[ 1900]		from 192.168.1.254  ttl 64
UDP open	            mdns[ 5353]		from 192.168.1.254  ttl 255
```

# სხვადასხვა

## Netcat

|   ო.ს    | ვინდოუსი, იუნიქსი  |

netcat-ს მარავალი დანიშნულება აქვს, მათ შორის ღია პორტების დადგენაც.

**სინტაქსი:**

```
nc [options] IP ან სახელი პორტების-range
```

**option-ები:**
  * -v უბრძანებს რომ აჩვენოს რაც შეუძლია მიმდინარე ოპერაციების შესახებ
  * -r უბრძანებს რომ პორტები ჰაზარდულად დაასკანიროს რომ IDS-ები მოატყუოს
  * -w2 უბრძანებს რომ 2 წამი დაიცადოს ყოველივე პორტის საკანირების შუალედში რახან IDS-ი მოტყუვდეს
  * -z უბრძანებს რომ zero I/O (Input/Output) რეჟიმში იმოქმედოს
  * -1-1024 უბრძანებს რომ დაასკანიროს პორტები 1-დან 1024-მდე

**მაგალითი:**

```
nc -v -r -w2 -z 67.44.83.29 1-1024
```

## Strobe

|   ო.ს    | იუნიქსი  |

strob-ი არის ართერთი ყველაზე ჩქარი ღია პორტების მაჩვენებელი, მაგრამ ზოგიერთ სერვის ვერ სცნობს (პორტი 445-ი არის Windows Shares და strobe-ი მხოლოდ წერს 445/TCP ).

**სინტაქსი:**

```
strobe IP
```

**მაგალითი:**

```
strobe 192.168.02
```

## RPC

|   ო.ს    | იუნიქსი  |

rpcinfo ასრულებს Remote Procedure Call (RPC) მსვერპლის მიმართ და გვატყობინებს თუ რა პორტებია ყია (TCP და UDP) და რომელი სერვერები არიან გაშვებულები. ეს ინფორმაცია საინტერესოა რომ ვიცოდეთ რომელი ექსპლოიტების გამაყენებაა შესაძლებელი.

**სინტაქსი:**

```
rpcinfo <options> IP
```

**მაგალითი:**

```
rpcinfo -p 132.45.67.54
```


## Fscan

|   ო.ს    | ვინდოუსი  |

Fscan-ის პლიუსები ის არის რომ მას შეუძლია random-ულად დაადგინოს პორტი ღიაა თუ არა, აგრეთვე შეუძლია IDS-ები (Intrusion Detection System) რომ მოატყუოს.
თან შეუძლია რომ გარკვეულ პორტზე ქნას სკანირება (ვთქვათ 80-ე პორტზე რახან firewall-ები ამ პორტთან დაკავშირებას ხშირად უშვებენ, პორტის აღნიშვნას უნდა option -i).

**სინტაქსი:**

```
fscan [options] IP [პორტი]
```

თუ სხვანაირად არ ანიშნეთ fscan-ი პორტებს ასკანირებს UDP-ი და TCP-იც.

  * -q უბრძანებს რომ პინგი არ იხმაროს სკანირების წინ
  * -r უბრძანებს რომ სკანირება random-ულად გაიმართოს.

ეს option-ები გვეხმარება რომ IDS-ი გადავლახოთ.

იცოდეთ რომ fscan-ი არ ასკანირებს 23-ე პორტს.


# დაცვა

IDS-ების ლოგების ნახვა, არა საჭირო სერვისების გათიშვა, firewall, host-based firewalls

# სხვა პროგამები

Angry IP, LANguard, cryptcat (netcat-ი კრიპტოგრაფიის შეძლებით), SuperScan
