საჭიროა რომ იყოს დაცული ვებ აპლიკაცია (frontend), მონაცემთა ბაზა (backend) და ქსელი. აქ აქცენტი იქნება frontend-ის უსაფრთხოებაზე როგორიცაა cross-site scripting (XSS), SQL injection, SSI injection, XML injection, სერვერების არასწორი კონფიგურირება, ფუნქციების არასწორად გამოყენება, სესიის გამოცნობა, ინფორმაციის გაჟონვა და სხვა.

# Nikto2

Nikto2 არის ვებ-სერვერის სისუსტეების დასადგენი სკანერი. იგი ადგენს სისუსტეებს არასწორი კონფიგურირების გამო, აჩვენებს დეფოლტ და არადაცულ ფაილებს და აგრეთვე სერვერის მოძველებულ აპლიკაციებს. მას შეუძლია რომ IDS-ს თავი აარიდოს, დაადგინოს ქვედადემენები, დაადგინოს XSS-ები, SQL ინექციები და სხვა. Brute force-ით პაროლების გატეხვა ლექსიკონის გამოყენებით, სერვერზე ბრძანებუს შესრულება და სერვერზე პროგრამების ვერსიების დადგენა.

Nikto2-ს დოკუმენტაცია: http://cirt.net/nikto2-docs/

```
hacker@kali ~> nikto -h www.hackthissite.org -p 80
- Nikto v2.1.6
---------------------------------------------------------------------------
+ Target IP:          137.74.187.102
+ Target Hostname:    www.hackthissite.org
+ Target Port:        80
+ Start Time:         2019-02-22 00:45:48 (GMT1)
---------------------------------------------------------------------------
+ Server: No banner retrieved
+ The anti-clickjacking X-Frame-Options header is not present.
+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS
+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type
+ Root page / redirects to: https://www.hackthissite.org/
+ No CGI Directories found (use '-C all' to force check all possible dirs)
+ 7517 requests: 0 error(s) and 3 item(s) reported on remote host
+ End Time:           2019-02-22 00:47:01 (GMT1) (73 seconds)
---------------------------------------------------------------------------
+ 1 host(s) tested
```

აგრეთვე იცოდეთ:
  * -T სკნირებისთვის აირჩიეთ სისუტეების კატოგირიები.
  * -t timeout-ი ყოველივე ტესტის პასუხისთვის
  * -D -V ეკრანზე აჩვენებს გაცილებით მეტ ინფორმაციას
  * -O -F მოცემული ფორმატის მიხედვით სკანირების რეზულტატს ინახავს ფაილში.
  * --mutate წდილობს რომ გამოიცნოს ქვედადომენები, ფაილების და პაპკების სახელები, მომხმარებლების ზედმეტი სახელები.
  * -evasion IDS-ს არიდებს თავს.
  * -Single ღრმა ტესტირებისთვის.


# OWASP ZAP

OWASP Zed Attack Proxy (ZAP) არის Java-ში დაწერილი ვებ აპლიკაციების სისუსტეების სკანერი. მას შეუძლია ვებ-გვერდების ვიზიტი, სისუსტეების დადგენა, fuzzing-ი და ვებ პროქსის ფუნქციის შესრულება.

![zap url](https://raw.githubusercontent.com/zonkey21/zonkey21.github.io/master/pictures/zap_url.png "zap url")

აკრიფე საიტის URL რომლის წინაშეც უნდა გაამართო შეტაკება და დააჭირე "Attack" ღილაკს.

![zap spider](https://raw.githubusercontent.com/zonkey21/zonkey21.github.io/master/pictures/zap_spider.png "zap spider")

ZAP-ი იწყებს საიტის ყოველივე გვერდის ვიზიტს. შემდეგ იგი ამოწმებს გავრცელებულ სისუსტეებს რომლებიც მითითებულები არიან Alerts ზონაში დაბლა მარცხნივ.

![zap alerts](https://raw.githubusercontent.com/zonkey21/zonkey21.github.io/master/pictures/zap_alerts.png "zap alerts")

[ZAP-ის შესახებ](https://www.owasp.org/index.php/ZAP)


# Burp Suite

Burp Suite-ს შეუძლია სკანირება, ანალიზი და ვებ აპლიკაციებზე ექსპლოიტების გაშვება ავტომატურად ან "ხელით".
არსებობს Burp Suite-ის ორი ვერსია უფასო და კომერციული.
http://www.portswigger.net/burp/help/

SQL ინექციის აღმოსაჩენად გასავლელია შემდგომი ეტაპები:
  - მიწვდით **Proxy > Options** და შეამოწმეთ რომ Proxy listeners-ი არ არის ცარიელი. ამ შემთხვევაში ვტოვებთ ნაგულისხმევ პორტ 8080. დამატებითი პარამეტრები როგორიცაა Host redirection, SSL certificate, Client request interception, Server response interception, Page properties, და Header modifications შეგიძლიათ შეცვალოთ თქვენი აპლიკაციის შესამოწმებელი კრიტერიუმებით.
  - მიწვდით **Proxy > Intercept**-ს და შეამოწმე რომ Intercept-ი გააქტიურებულია.
  - შენს ვებ ბრაუზერის პარამეტრებში ლოკალური პროქსის მიუთითე HTTP/HTTPs მიმოსვლითვის ( 127.0.0.1, 8080 ) რომ ვების ქსელური მიმოსვლის request-ების ხელში ჩაგდება, ინსპექცია და ცვლილებების შეტანა შეძლო. ანუ ლაპარაკის ქსელურ მიმოსვლაზე რომელიც იმართება ბრაუზერის ად ვენ აპლიკაციის შორს. ამის მერე მოსული პასუხები იქნება დაფიქსირებული და შენახული. Burp Suite-ი მოქმედებს როგორც კაცი შუაში (man-in-the-middle (MITM)) პროქსი.
  - ეწვიე ვებ საიტს (მაგალითად, http://hackthissite.org) და შეამჩნევ რომ request-ი დაფიქსირდა **Proxy > Intercept**-ში. ჩვენს შემთხვევაში, გადავწყიტეთ ამ request-ის გატარება ცვილებების შეტანის გარეშე. თუ გადაწყვეტ ასეთი request-ის შეცვლა, მასე შეგიძლია Raw, Headers და Hex ტაბებით. ვებ გვერდზე არსახული სხვა რესურსების მიწვდომისას (როგორიცაა სურათები, ვიდეოები და სხვა) ვითარდება თითეული request-ი.

შეპრყობილი ტრეფიკის მოსახმარებლად შეგიძლია იხმარო შემდგომი შესაძლებლობები რომლებიც Burp Suite-ის თამ მოჰყვება:
  * Spider: ეს გაძლევთ საშუალებას რომ საიტზე არსებულ ბრუმელბს გაჰყვეთ და დაადგინოთ როგორც საიტის სიღრმე აგრეთვე დაუცველი ვებ გვერდები.
  * Repeater: ხელახლათ აგზავნის HTTP/HTTPS რომ კიდევ ერთხელ ნახოთ მისი რეზულტატი. ეს საჭიროა როც გინდათ ნახოთ სესიის ID-ეები რადგან შეტაკება ვერ განხორციელდება თუ იგი სწორ მონაცემს არ ემთხვევა.
  * Intruder: ტრეფიკის ხელში დაჭერის შემდგომ, Burp Suite-ს გააჩნია სხვადასხვა ხელსაწყოები შეტაკებების განსახორციებლად და ვებ აპლიკაციების დაცულობის ტესტირებისთვის. intruder-ი შეტაკების კონფიგურირების საშუალებას გაძლევს, მაგალითად brute force-ით ან ასოების მანიპულაციით.
  * Comparer: ბიტების დონეზე ადარებს ხელში ჩაგდებულ ქსელურ ტრეფიკს, ეს დაგეხმარება წვრილი ცვლილებების აღმოჩენაში რომლებიც ერთბაშად მარტივად არ ჩანს (სესიის ID-ს ცვლილება და სხვა).


Burp Suite-ი კიდევ ბევრი სხვა შესაძლებლობა გააჩნია ვებ აპლიკაციების ტესტირებისთვის. მითითებულ საიტზე შეგიძლია გაეცნო უფრო დაწვრილებით: http://www.portswigger.net.

# Paros პროქსი

პროქსი ასრულბს შუალედის როლს თქვენს ვებ ბრაუზერსა და ვებ საიტის შორის. გაძლევთ საშუალებას რომ ხელში ჩაიგდოთ ქსელური ტრეფიკი რადგან განახორციელოთ მისი ანალიზი და ვებ რექვესტებში ცვლილებების შეტანას.
მაშასადანე პაროს პროქსი ასრულებს ქსელური უშიშროების ხელსაწყოს აქტიურ და პასიურ როლს.

სანამ პაროსს იხმართ საჭიროა თქვენს ვებ ბრაუზერში პროქსის კონფიგურირებ: (ლოკალური პროქსი, IP: 127.0.01, პორტი: 8080). ვებ ბრაუზერის კონფიგურირების შემდგომ შეგიძლიათ ეწვიოთ თქევნს მიერ არჩეულ ვებ საიტს.

სისუსტეების დადგენა mutillidae პროექტის გამოყენებით, ეს გახლავთ ძალით დაუცველი ვებ აპლიკაცია. გაეცნეთ ამ პროეტს (http://sourceforge.net/projects/mutillidae/, http://github.com/webpwnized/mutillidae).

  - შევდივართ საიტზე http://192.168.0.30/mutillidae და შეამჩნიეთ რომ იგი გამოჩნდა პაროს პროქსის **Sites**-ს ტაბში.
  - http://192.168.0.30/mutillidae-ზე დააწკაპუნეთ მარჯვენა და აირჩიეთ **Spider**-ი რომ საიტი ყოველოვე გვერდი იყოს ნახული. ამ პროცესს დრო სჭირდება საიტის სიდიდისმდაგვარად.
  - როც საიტის ყველა გვერდი იქნა აღმოჩენილი, შეგიძლიათ ისინი ნახოთ **Spider** ტაბში, დაბლა. თან შეგიძლიათ დაზუსტებით ნახოთ გარკევული რექვესტი და მისი პასუხი მარცხნივ **Site**-ის ტაბში.
  - შემდგომი რექვესტების ხაფანგში მოქცევისთვის მარჯვენა პანელში დაუწკაპუნეთ **Trap**-ს. ეს მოსახერხებელია საიტის "ხელით" შემოწმებისთვის. HTTP რექვესტების შექმნისთვის ცადეთ **Tools | Manual Request Editor**.
  - საიტის ავტომატურად ტესტირებისთვის ვირჩევთ სატესტო საიტს **Sites**-ს ტაბში და მენიუდან ვირჩევთ **Analyze | Scan All**. სპეციფიკური ანალიზისთვის ნახეთ **Analyze | Scan Policy**.
  - როცა ტესტირება დასრულდა, ნახეთ რეზულტატი და სისუსტეების რაოდენობა Alerts-ს ტაბში, დაბლა.
  - სკანირების რეპორტისთვის მენიუდან მიდით **Report | Last Scan Report**.

ეს არის პაროსის მარტივი გამოყენება, უფრო დაწვრილებით რომ გამოიყენოთ, გაეცანით http://www.i-pi.com/Training/SecTesting/paros_user_guide.pdf

# W3AF

[[ქსელი:http:w3af|ნახეთ]]

# WafW00f

ადგენს ვებ ფაივოლის არსებობას (Web Application Firewall). ვებ ფაივოლის არსებობის შემთხვევაში, საიტის ტესტირებისთვის უნდა გამოიყენოთ ფილტრაციის გასარღვევი ტექნიკები.

```
hacker@kali ~> wafw00f example.com

                                 ^     ^
        _   __  _   ____ _   __  _    _   ____
       ///7/ /.' \ / __////7/ /,' \ ,' \ / __/
      | V V // o // _/ | V V // 0 // 0 // _/
      |_n_,'/_n_//_/   |_n_,' \_,' \_,'/_/
                                <
                                ...'

    WAFW00F - Web Application Firewall Detection Tool

    By Sandro Gauci && Wendel G. Henrique

Checking http://example.com
The site http://example.com is behind a Edgecast / Verizon Digital media
Number of requests: 1
```

ვხედავთ რომ საიტი ვებ ფაირვოლით არის დაცული, ამიტომ ტესტირების გასაგრძელებლად უნდა გამოვიყენოთ ფილტრაციის თავიდან ასაცილებელი ტექნიკები: HTTP parameter pollution, null-byte replacement, normalization, URL-ის ენკოდინგი Hex-ში ან Unicode-ში.

# WebScarab

WebScarab-ის გამოყენების ერთერთი კარგია ვარიანტია მისი პროქსის მეშვეობით ვებ აპლიკაციების ტესტირება.
მისი პროქსის მეშვეობით ნახავთ როგორ რექვესტებს უგხავნით ვერ აპლიკაციას და რა პასუხები მოგსდით, შეგეძლებათ ამ რექვესტების შეცვლა რომ ვებ აპლიკაციის დაცვის სისტემას გვერდით აუაროთ.
აგრეთვე შეუძლია fuzzing-ი, სესიის ID-ების ანალიზი, საიტის ყოველივე ვებ გვერდის სტუმრობა, ვებ სერვისების ანალიზი, XSS-ის და CRLF-ის ტესტირება და სხვა.

გაუშვი WebScarab-ი:

```
hacker@kali ~> webscarab
```

ვიხმაროთ ყოველივე ფუნქცია, ამისთვის მენიუში ავირჩიოთ **Tools | Use full-featured
interface**. არჩევანის დადასტურების შემდეგ WebScarab-ი ახლიდან უნდა გაუშვათ. როცა WebScarab-ს ახლიდან გაუშვებთ დაინახავთ სხვადასხვა ხელსაწყოების ტაბებს.
შემდგომ ბრაუზერის ლოკალურ პროქსის კონფიგურირებას ვაკეთებთ (IP: 127.0.0.1, პორტი: 8080) რომ ვებ აპლიაციას მისწვდეთ WebScarab-ის პროქსის შუამავლობით.

  - შედით დაუცველ საიტზე http://192.168.0.30/mutillidae და ასტუმრეთ სხვადასხვა ბმულებს, რაც უფრო მეტს ესტუმრებით უფრო მეტია შანსია რომ დაუცველი გვერდი აღმოაჩინოს WebScarab-მა. ნა სხვა მიდგომით შეგიძლიათ შეარჩიოთ საიტი **Summary** ტაბის ქვეშ და მარვენა დაწკაპუნებით აირჩიოთ **Spider tree**. ამით WebScarab-ი ეწვევა საიტის ყოველივე ბმულს.
  - თუ გინდათ რომ თვალი ადევნოთ რექვესტებს და პასუხებს **Summary**-ი ტაბში აირჩიეთ გვერდის სახელწოდება და ორჯერ დაუწკაპუნეთ.
  - გვინდა რომ გამოვიყენოთ fuzzing-ი. მაგალიტად ვსინჯოთ სხვადასხვა მონაცემები ვებ გვერდის id პარამეტრისთვის, HTTP GET მეთოდით. მარვენა დაწკაპუნებით აირჩიე ბმული და აირჩიე **Use as fuzz template**. დაუწკაპუნე Fuzzer ტაბს და შეიტანე სხვადასხვა მონაცემები id პარამეტრისთვის **Add** ღილაკით, სექცია **Parameters**-ის ახლოს. მაგალითად შეგვაქვს ცნობილი SQL ინექციის კალისკური სახეობები (1 AND 1=2, 1 AND 1=1 , ') fuzzer-ის წყარო მონაცემებათ. ამისთვის ვხმარობთ **Sources** ღილაკს, **Fuzzer** ტაბის ქვეშ. და ვაწკაპუნბთ **Start**-ზე. როცა ყოველივე რექვესტი იქნება განხორციელებული შეგიძლიათ დაუწკაპუნოთ გარკვეულ რექვესტს და დეტალურად ნახავთ პასუხს. ერთერთ გვერდზე აღმოვაჩინეთ SQL ინექცია <code>mysql_fetch_array(): supplied argument is not a valid MySQL result resource in /var/www/vhosts/default/htdocs/listproducts.php on line 74</code>
  - შემდეგ გვინდა აპლიკაციის სესიის ID-ის ანალიზი. ამისთვის, ვაწკაპუნებთ **SessionID Analysis** ტაბზე და ვირჩევთ **Previous Requests**. როცა არჩეული რექვესტი ჩატვირთულია, დაბლა აირჩიე სამაგალითო რექვესტები, დაუწკაპუნე **Fetch**-ს რომ ჩაიტვირთოს რექვესტების სესიის ID-ეები. შემდოგ დაუწკაპუნე **Test** ღილაკს რომ დაიწყოს ანალიზის პროცესი. რეზულტატს ნახავთ **Analysis** ტაბში, და გრაფიკული აღწერა **Visualization** ტაბში. ეს პროცესი ადგენს სესიის ID-ს შემთხვევითობას, რასაც შეუძლია საფუძველი მისცეს სხვა მომხმარებლების სესიების ხელში ჩასაგდებად.

დაწვრილებით გაეცანით ამ პროგრანის კოკუმენტაცია: http://www.owasp.org/index.php/Category:OWASP_WebScarab_Project
