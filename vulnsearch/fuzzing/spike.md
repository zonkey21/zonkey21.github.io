# SPIKE Fuzzer

SPIKE არის ქსელური პროგრამების/პროტოკოლების fuzzer-ების შექმნის კიტი, SPIKE-ით შეგიძლია fuzzing-ის სესიების სკრიპტირება მისი API-ის მეშვეობით, C ენაში.
SPIKE-ში დეკლარილებული ფუნქციების გამოყენებით, C პროგრამისტს შეუძლია რომ შექმნას თავისი fuzzing-ის მესიჯები, ასეთ მესიჯებს ამ შემთხვევაში ეწოდება "სპაიკები", ქსელური პროგრამებისთვის ამ მესიჯების გაგზავნით შეგიძლია პროგრამა შეცდომაში შეიყვანო, რაც აღნიშნავს რომ პოტენციური ბუგები იპოვე.
SPIKE-ი გამიზნულია იმისთვის რომ საექსპლუატაციო ბუგები იპოვოს და არა უბრალო ბუგები, ამიტომ იგი კარგია ჰაკერებისთვის.

C-ში პროგრამირება არაა საჭირო, SPIKE-ს აგრეთვე მოყვება სკრიპტის ენა რომლითაც შეგიძლია დაწერო შენი fuzzing-ის სცენარები და შემდეგ იხმარო ბრძანებები რომლებიც SPIKE-ს მოყვება და ინტერპრეტერის როლს ასრილენენ, სკრიპტების გასაშვებად.


# SPIKE-ის საინტერესო თვისებები

* SPIKE-ს მოყვება მრავალი string-ები fuzzing-ისთვის, ეს string-ები ეფექტურია პროგრამების შეცდომაში შეყვანისთვის. SPIKE-ი ეცდება შეარჩიოს საუკეთესო გასაგზავნი string-ი, ეს იმას ნიშნავს რომ შენ არ გჩირდება string-ების შერჩევისთვის თავის ტეხვა.
* SPIKE იყენებს "ბლოკების" კონცეპტს, რომ დაადგინოს "სპაიკების" სექციების სიგრძე. ეს პრაქტიკულია პროტოკოლების fuzzing-ისთვის რომლებსაც ყოველთვის სჭირდებათ მესიჯების სექციების ზუსტი სიგრძე. 
* SPIKE-ს შეუძლია გამოიყენოს სხვადასხვა მონაცემთა ტიპები, რომლებიც ხშირად იხმარებიან ქსელურ პროტოკოლებსი.


# SPIKE-ისთვის სკრიპტინგი

შეგიძლია რომ SPIKE ფუნქციები გამოიყენო რომ ფუზინგი ჩაატარო და არ დაგჭირდეს შენი ფუზერის პროგრამირება.
SPIKE-ისთვის სკრიპტების დაბოლოებაა .spk.
SPIKE-ს სხვადასხვა "ინტერპრეტერები" (მაგალითად generic_send_tcp, generic_send_udp) მოყვება, "ინტერპრეტერების" როლია, სკრიპტის ანალიზი, "სპაიკების" შექმნა და მათი გაგზავნა ქსელური პროგრამისთვის, სპეციფიკურ IP მისამართზე და პორტზე.


# გამოყენება

**სინტაქსი:**
```
./generic_send_tcp host port spike_script SKIPVAR SKIPSTR
```

**მაგალითი:**
```
./generic_send_tcp 192.168.1.100 701 something.spk 0 0
```

პარამეტრები, SKIPVAR და SKIPSTR, გაძლევს საშუალებას რომ fuzzing-ის სესია გააკონტროლო.

**SKIPVAR:**

SPIKE-ის სკრიპტებში, შეგიძლია მიუთითო "s_string_variable-ები", ეს არის ფუნქცია რომელიც "სპაიკებში" აქცევს string-ებს რომლებიც გამოყენებულნი იქნება fuzzing-ისთვის. 
მაგალითად, თუ s_string_variable()-ს ათჯერ ხმარობ და გინდა რომ პირველი 3 string-ი არ იყოს ნახმარი მაშინ SPIVAR-ი უნდა უდრიდეს 2-ს, იმიტომ რომ ინდექსი 0-დან იწყება.

**SKIPSTR:**

ყოველივე s_string_variable-ებს აქვს მიწვდომა მასივთან რომელშიც არიან ახწერილნი SPIKE-ის სხვადასხვა fuzz string-ები, fuzzing-ის სესიის დროს შეგიძლია ამ string-ების იტერაცია.
როგორც წინა მაგალითში, თუ გსურს fuzzing-ის დაწყება მეთერთმეტე string-იდან მაშინ SKIPSTR-ი უნდა უდრიდეს 10-ს.

## Fuzzing-ის გაგრძელება

generic_send_tcp ტერმინალში თანდათან ბეჭდავს რომელი string იმოწმება, ასე რომ შეგიძლია fuzzing-ით ტესტირების სესია შეწყვიტო და შემდეგ გააგრძელო საიდანაც გააჩერე, ამისთვის უნდა დაიმახსოვრო SPIPVAR და SKIPSTR პარამეტრების value.


## Fuzzing-ის დაწყება

რომ fuzzing-ი თავიდან დაიწყო უნდა მიუთითო "0 0″, ესენი არიან SKIPVAR და SKIPSTR პარამეტრების value-ები.
Backtrack-ში SPIKE-ის "ინტერპრეტერი" generic_send_tcp არის შემდგომ პაპკაში /pentest/fuzzers/spike/

**მაგალითი:**
```
# /pentest/fuzzers/spike/generic_send_tcp 192.168.56.101 9999 test.spk 0 0
```


## SPIKE-ის ფუნქციები

SPIKE-ის გამოყენებისთვის ტესტირებისთვის შედგენილი string-ებს ქვია "სპაიკები", იგი არიან შედგენილები სკრიპტების "ინტერპრეტერის" მიერ, შემდეგ "ინტერპრეტერი" უზრუნველყოფს ამ "სპაიკების" გაგზავნას შორეული პროგრამისკენ.
"სპაიკების" შესაქმნელად არსებობს ფუნქციები, რომლებსაც გთავაზობ.

### string-ები

```
s_string(“string”); // უბრალოდ ბეჭდავს “string”-ს გასაგზავნელ “სპაიკში”
s_string_repeat(“string”,200); // “string” 200-ჯერ ბეჭდავს
s_string_variable(“string”); // ფუზინგის string-ი შეაქვს “სპაიკში”.
```

#### მონაცემები ორობითში

```
s_binary(“\\x41″); // შეაქვს hex 0×41 = ASCII “A” ორობითში
s_binary_repeat(“\\x41″, 200); // 200 ჯერ შეაქვს 0x41 ორობითში
```

#### ბლოკის შექმნა

```
s_block_start(“block1″); // ბლოკი “block1″ იწყება
s_block_end(“block1″);   // ბლოკი “block1″ მთავრდება
```

#### ბლოკის სიგრძე

```
s_blocksize_string(“block1″, 2); // block1 სიგრძის "სპაიკს" უმატებს 2 ასოიან string-ს 
s_binary_block_size_byte(“block1″); // block1 სიგრძის "სპაიკს" უმატებს 1 ასოიან string-ს
```

ესენი მხოლოდ მაგალითები არიან, აგრეთვე არსებობს სხვა მეთოდები ბლოკების სიგრძის დასადგენად.


#### სხვა ფუნქციები

```
    s_read_packet(); // ბეჭდავს სერვერისგან მიღებულ მონაცემებს
    s_readline(); // ბეჭდავს სერვირისგან მიღებულ მხოლოდ 1 ხაზს
```

SPIKE სკრიპტებში აგრეთვე შეგიძლია C ფუნქციების გამოყენება, მაგალითად printf()-ის, რომ ტერმინალში დაბეჭდო მონაცემები.



# SPIKE-ის სკრიპტის მაგალითი

შემდეგი სამაგალითო SPIKE-ის სკრიპტი fuzzing-ს ახორციელებს testme.php-ს inputvar ცვლადის წინააღმდეგ, ეს მონაცემი იგზავნება HTTP POST რექვესტით testserver.example.com-თან.

```
s_string("POST /testme.php HTTP/1.1\r\n");
s_string("Host: testserver.example.com\r\n");
s_string("Content-Length: ");
s_blocksize_string("block1", 5); // block1-ს ემატება 5 ბაიტი
s_string("\r\nConnection: close\r\n\r\n");
s_block_start("block1");  // იწყება POST რექვესტის სიგრძის გაზომვა
s_string("inputvar=");
s_string_variable("inputval"); // აქ მოთავსდება SPIKE-ის fuzz string-ები, ამის value შეიცვლება იმიტომ რომ სხვადასხვა string-ების ტესტირება მოხდება რიგრიგობით.
s_block_end("block1"); // მრთავდება POST რექვესტის სიგრძის გაზომვა
```

ეს სკრიპტი მაგალითად შექმნის HTTP რექვესტს როგორც:

```
POST /testme.php HTTP/1.1
Host: testserver.example.com
Content-Length: [მონაცემების სიგრძე]
Connection: close
inputvar=[ფუზინგის string-ი]
```


# რავალი SPIKE-ის სკრიპტები

სამწუხაროთ ვერ შემნი ბევრ "სპაიკებს" მხოლოდ ერთ სკრიპტში. თუ fuzzing-ისთვის გსურს სინჭო ბევრი უცვლელი ზომის მესიჯები მაშინ გჭირდება იმდენივე  SPIKE-ის სკრიპტი რომელშიც გამოიყენებ ფუნქციას s_string_variable().


წყარო: http://resources.infosecinstitute.com/intro-to-fuzzing/

